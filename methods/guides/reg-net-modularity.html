---
layout: methods-guide
title: "Community Detection: Modularity & Algorithms"
title_zh: "社区检测：模块性与算法"
parent_title: "Network Analysis"
parent_title_zh: "网络分析"
parent_url: "reg-network.html"
bilingual: true
mathjax: true
---

<style>
.level-badge{display:inline-flex;align-items:center;gap:6px;font-family:var(--sans);font-size:10px;font-weight:600;letter-spacing:.1em;text-transform:uppercase;padding:4px 12px;border-radius:20px;margin-bottom:8px}
.level-badge.beginner{background:rgba(91,140,133,.12);color:#4a7a72}
.level-badge.intermediate{background:rgba(194,153,61,.12);color:#9a7a2e}
.level-badge.advanced{background:rgba(181,55,42,.1);color:#a0382e}
.depth-divider{display:flex;align-items:center;gap:16px;margin:40px 0 28px}
.depth-divider::before,.depth-divider::after{content:'';flex:1;height:1px;background:var(--parchment)}
.depth-divider span{font-family:var(--sans);font-size:10px;font-weight:600;letter-spacing:.14em;text-transform:uppercase;color:var(--ink-ghost);white-space:nowrap}
.concept-row{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin:20px 0}
.concept-card{background:var(--paper);border:1px solid var(--parchment);border-radius:6px;padding:18px 20px;transition:all .3s ease;box-shadow:0 1px 3px rgba(30,24,15,.03)}
.concept-card:hover{border-color:var(--gold-soft);box-shadow:0 3px 12px rgba(194,153,61,.08);transform:translateY(-1px)}
.concept-card .card-icon{font-family:var(--sans);font-size:10px;font-weight:700;letter-spacing:.1em;text-transform:uppercase;color:var(--paper);background:var(--gold);display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:6px;margin-bottom:10px;box-shadow:0 2px 4px rgba(194,153,61,.2)}
.concept-card h4{font-family:var(--sans);font-size:13px;font-weight:600;color:var(--ink-soft);margin:0 0 6px}
.concept-card p{font-size:13.5px;line-height:1.7;color:var(--ink-faded);margin:0}
.guide-formula{background:rgba(30,24,15,.03);border:1px solid var(--parchment);border-radius:6px;padding:20px 24px;margin:20px 0;text-align:center;font-size:16px;line-height:1.8;color:var(--ink-soft);font-family:var(--mono);letter-spacing:.02em;overflow-x:auto}
.unpack-list{display:grid;grid-template-columns:1fr;gap:10px;margin:16px 0;padding:0;list-style:none}
.unpack-item{display:flex;gap:14px;align-items:flex-start;padding:12px 16px;background:var(--paper);border:1px solid var(--parchment);border-radius:6px;transition:border-color .25s}
.unpack-item:hover{border-color:var(--gold-soft)}
.unpack-item .symbol{font-family:var(--mono);font-size:14px;font-weight:600;color:var(--gold);white-space:nowrap;min-width:80px;padding-top:1px}
.unpack-item .explain{font-size:13.5px;line-height:1.7;color:var(--ink-faded)}
.callout{border-left:3px solid var(--gold);background:rgba(194,153,61,.04);padding:16px 20px;margin:20px 0;border-radius:0 6px 6px 0}
.callout.tip{border-left-color:#5b8c85;background:rgba(91,140,133,.04)}
.callout.warn{border-left-color:var(--red);background:rgba(181,55,42,.04)}
.callout .callout-label{font-family:var(--sans);font-size:10px;font-weight:700;letter-spacing:.12em;text-transform:uppercase;color:var(--gold);margin-bottom:6px}
.callout.tip .callout-label{color:#5b8c85}
.callout.warn .callout-label{color:var(--red)}
.callout p{font-size:14px;line-height:1.75;color:var(--ink-faded);margin:0}
.callout p + p{margin-top:8px}
.step-flow{display:grid;grid-template-columns:1fr;gap:10px;margin:16px 0;padding:0;list-style:none;counter-reset:step}
.step-flow li{counter-increment:step;display:flex;gap:14px;align-items:flex-start;padding:12px 16px;background:var(--paper);border:1px solid var(--parchment);border-radius:6px;font-size:13.5px;line-height:1.7;color:var(--ink-faded);transition:border-color .25s}
.step-flow li:hover{border-color:var(--gold-soft)}
.step-flow li::before{content:counter(step);font-family:var(--sans);font-size:11px;font-weight:700;color:var(--paper);background:var(--gold);min-width:26px;height:26px;border-radius:50%;display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-top:1px;box-shadow:0 1px 3px rgba(194,153,61,.2)}
.code-block{background:var(--ink);color:#e8e0d4;padding:24px 28px;border-radius:6px;overflow-x:auto;font-size:13px;line-height:1.55;font-family:var(--mono);margin:20px 0;box-shadow:0 2px 8px rgba(30,24,15,.15)}
.code-block .comment{color:#9a8e7e}
.collapsible-toggle{display:flex;align-items:center;gap:8px;cursor:pointer;padding:12px 0;font-family:var(--sans);font-size:12px;font-weight:600;letter-spacing:.06em;text-transform:uppercase;color:var(--ink-ghost);border:none;background:none;transition:color .25s}
.collapsible-toggle:hover{color:var(--gold)}
.collapsible-toggle .arrow{transition:transform .3s;font-size:10px}
.collapsible-toggle.open .arrow{transform:rotate(90deg)}
.collapsible-content{max-height:0;overflow:hidden;transition:max-height .4s ease}
.collapsible-content.open{max-height:5000px}
.summary-box{background:var(--warm);border:1px solid var(--parchment);border-radius:6px;padding:24px 28px;margin:28px 0}
.summary-box .summary-label{font-family:var(--sans);font-size:10px;font-weight:700;letter-spacing:.12em;text-transform:uppercase;color:var(--gold);margin-bottom:10px}
.summary-box p{font-size:14px;line-height:1.75;color:var(--ink-faded);margin:0}
body.zh .step-flow li,body.zh .unpack-list .unpack-item{display:flex}
@media(max-width:700px){.concept-row{grid-template-columns:1fr}.unpack-item{flex-direction:column;gap:4px}.unpack-item .symbol{min-width:auto}}
</style>

<h2 data-lang="en">What Is Community Detection?</h2>
<h2 data-lang="zh">什么是社区检测？</h2>

<div class="level-badge beginner">Beginner</div>

<p data-lang="en">
Imagine a high school cafeteria where students sit in tables based on their friendships. A community detection algorithm is like a detective who looks at the seating chart and discovers these friend groups without anyone telling them what the groups are. The algorithm needs only one piece of information: who sits next to whom.
</p>

<p data-lang="zh">
想象一个高中食堂，学生根据他们的友谊坐在桌子旁。社区检测算法就像一个侦探，看着座位表，发现这些朋友圈，不需要任何人告诉他们这些圈子是什么。该算法只需要一种信息：谁与谁相邻。
</p>

<div class="concept-row">
  <div class="concept-card">
    <div class="card-icon">C</div>
    <h4 data-lang="en">Community</h4>
    <h4 data-lang="zh">社区</h4>
    <p data-lang="en">A group where nodes are densely connected to each other, but sparsely connected to the rest of the network. Like a cluster of friends.</p>
    <p data-lang="zh">一个节点彼此密集连接，但与网络其余部分稀疏连接的组。就像一群朋友。</p>
  </div>

  <div class="concept-card">
    <div class="card-icon">Q</div>
    <h4 data-lang="en">Modularity (Q)</h4>
    <h4 data-lang="zh">模块性 (Q)</h4>
    <p data-lang="en">A score that measures how good a partition is. Higher Q means clearer community structure. Range: −0.5 to 1.0 (typically 0 to 0.5).</p>
    <p data-lang="zh">衡量分割有多好的分数。较高的 Q 意味着更清晰的社区结构。范围：−0.5 到 1.0（通常 0 到 0.5）。</p>
  </div>
</div>

<div class="callout tip">
  <div class="callout-label" data-lang="en">Key Insight</div>
  <div class="callout-label" data-lang="zh">关键见解</div>
  <p data-lang="en">The algorithm doesn't need labels. It discovers structure purely from the connection pattern. This is what makes it powerful—it works even when you don't know what the communities represent.</p>
  <p data-lang="zh">该算法不需要标签。它纯粹从连接模式中发现结构。这就是它的强大之处——即使你不知道社区代表什么，它也能工作。</p>
</div>

<div class="depth-divider"><span data-lang="en">The Louvain Algorithm</span><span data-lang="zh">Louvain 算法</span></div>

<h2 data-lang="en">How Louvain Works</h2>
<h2 data-lang="zh">Louvain 如何工作</h2>

<div class="level-badge beginner">Beginner</div>

<p data-lang="en">
Louvain is the most popular community detection method. It's fast, scalable, and works on networks with millions of nodes. The algorithm uses a clever two-step process that repeats until the communities stop improving.
</p>

<p data-lang="zh">
Louvain 是最流行的社区检测方法。它速度快，可扩展，并且适用于拥有数百万个节点的网络。该算法使用一个聪明的两步流程，重复直到社区停止改进。
</p>

<ol class="step-flow">
  <li data-lang="en">Start with each node in its own community</li>
  <li data-lang="zh">从每个节点都在自己的社区中开始</li>

  <li data-lang="en">For each node, try moving it to each neighbor's community. Keep the move that increases modularity Q the most</li>
  <li data-lang="zh">对于每个节点，尝试将其移动到每个邻居的社区。保持最增加模块性 Q 的移动</li>

  <li data-lang="en">Once no move improves Q, merge each community into a single "super-node" and repeat steps 1-2 on this new network</li>
  <li data-lang="zh">一旦没有移动改进 Q，将每个社区合并为一个"超级节点"，并在这个新网络上重复步骤 1-2</li>

  <li data-lang="en">Stop when Q no longer increases between iterations</li>
  <li data-lang="zh">当 Q 在迭代之间不再增加时停止</li>
</ol>

<div class="callout tip">
  <div class="callout-label" data-lang="en">Why Louvain?</div>
  <div class="callout-label" data-lang="zh">为什么选择 Louvain？</div>
  <p data-lang="en">Louvain is greedy (it makes locally optimal choices) rather than globally optimal, but this makes it fast and practical. For most real networks, it finds excellent results in seconds.</p>
  <p data-lang="zh">Louvain 是贪心的（它做出局部最优选择）而不是全局最优的，但这使它快速且实用。对于大多数真实网络，它在几秒钟内找到优异的结果。</p>
</div>

<div class="depth-divider"><span data-lang="en">The Mathematics</span><span data-lang="zh">数学基础</span></div>

<h2 data-lang="en">Understanding Modularity Q</h2>
<h2 data-lang="zh">理解模块性 Q</h2>

<div class="level-badge intermediate">Intermediate</div>

<p data-lang="en">
Modularity measures: are there more edges inside communities than expected by random chance? It compares the actual network against a null model—a random graph with the same degree distribution but no structure.
</p>

<p data-lang="zh">
模块性度量：社区内的边是否比随机机会预期的要多？它将实际网络与零模型进行比较——具有相同度分布但没有结构的随机图。
</p>

<div class="guide-formula">
Q = (1/2m) Σ_{i,j} [A_{ij} − k_i k_j / 2m] δ(c_i, c_j)
</div>

<p data-lang="en"><strong>Breaking down each piece:</strong></p>
<p data-lang="zh"><strong>分解每一部分：</strong></p>

<ul class="unpack-list">
  <li class="unpack-item">
    <span class="symbol" data-lang="en">A_{ij}</span>
    <span class="symbol" data-lang="zh">A_{ij}</span>
    <span class="explain" data-lang="en">Adjacency matrix: 1 if nodes i and j are connected, 0 otherwise. The actual edges in your network.</span>
    <span class="explain" data-lang="zh">邻接矩阵：如果节点 i 和 j 相连则为 1，否则为 0。网络中的实际边。</span>
  </li>

  <li class="unpack-item">
    <span class="symbol" data-lang="en">k_i, k_j</span>
    <span class="symbol" data-lang="zh">k_i, k_j</span>
    <span class="explain" data-lang="en">Degree (number of connections) of nodes i and j. A hub has high degree.</span>
    <span class="explain" data-lang="zh">节点 i 和 j 的度数（连接数）。枢纽节点的度数很高。</span>
  </li>

  <li class="unpack-item">
    <span class="symbol" data-lang="en">k_i k_j / 2m</span>
    <span class="symbol" data-lang="zh">k_i k_j / 2m</span>
    <span class="explain" data-lang="en">Expected edges in a random null model. Given the degrees, how many edges would we expect purely by chance?</span>
    <span class="explain" data-lang="zh">随机零模型中的期望边数。给定度数，我们会纯粹凭机会期望多少条边？</span>
  </li>

  <li class="unpack-item">
    <span class="symbol" data-lang="en">m</span>
    <span class="symbol" data-lang="zh">m</span>
    <span class="explain" data-lang="en">Total number of edges in the network. (sum of all degrees) / 2</span>
    <span class="explain" data-lang="zh">网络中的总边数。（所有度的总和）/ 2</span>
  </li>

  <li class="unpack-item">
    <span class="symbol" data-lang="en">δ(c_i, c_j)</span>
    <span class="symbol" data-lang="zh">δ(c_i, c_j)</span>
    <span class="explain" data-lang="en">Kronecker delta: equals 1 if i and j are in the same community, 0 otherwise. Only counts pairs in the same group.</span>
    <span class="explain" data-lang="zh">Kronecker delta：如果 i 和 j 在同一社区则等于 1，否则为 0。仅计算同一组中的对。</span>
  </li>
</ul>

<h3 data-lang="en">Interpretation of Q Values</h3>
<h3 data-lang="zh">Q 值的解释</h3>

<div class="callout">
  <p data-lang="en"><strong>Q ≤ 0:</strong> No community structure (worse than random)</p>
  <p data-lang="zh"><strong>Q ≤ 0：</strong> 无社区结构（比随机差）</p>

  <p data-lang="en"><strong>Q = 0.1–0.3:</strong> Weak but real structure</p>
  <p data-lang="zh"><strong>Q = 0.1–0.3：</strong> 弱但真实的结构</p>

  <p data-lang="en"><strong>Q ≥ 0.3:</strong> Significant, meaningful communities</p>
  <p data-lang="zh"><strong>Q ≥ 0.3：</strong> 显著的、有意义的社区</p>

  <p data-lang="en"><strong>Q > 0.7:</strong> Very strong structure (rare in real networks)</p>
  <p data-lang="zh"><strong>Q > 0.7：</strong> 非常强的结构（在真实网络中很少见）</p>
</div>

<h3 data-lang="en">Worked Example: Two Triangles with a Bridge</h3>
<h3 data-lang="zh">示例：两个三角形与桥</h3>

<p data-lang="en">
<strong>Network:</strong> Community A = {1, 2, 3} (fully connected), Community B = {4, 5, 6} (fully connected), one edge 3-4 connecting them. Total: 7 edges.
</p>

<p data-lang="zh">
<strong>网络：</strong> 社区 A = {1, 2, 3}（完全连接），社区 B = {4, 5, 6}（完全连接），一条边 3-4 连接它们。总共：7 条边。
</p>

<div class="guide-formula" style="font-size: 14px; text-align: left;">
<strong data-lang="en">Calculation:</strong>
<strong data-lang="zh">计算：</strong>

<span data-lang="en">Edges within A: 3, Edges within B: 3, Bridge edges: 1, m = 7</span>
<span data-lang="zh">A 内的边：3，B 内的边：3，桥边：1，m = 7</span>

<span data-lang="en">Degrees: k = [2, 2, 3, 3, 2, 2]</span>
<span data-lang="zh">度数：k = [2, 2, 3, 3, 2, 2]</span>

<span data-lang="en">Q = (1/14) × Σ [observed − expected within-community pairs]</span>
<span data-lang="zh">Q = (1/14) × Σ [社区内观察到的 − 期望对数]</span>

<span data-lang="en"><strong>Q ≈ 0.29</strong> (weak-to-significant structure)</span>
<span data-lang="zh"><strong>Q ≈ 0.29</strong>（弱到显著的结构）</span>
</div>

<div class="depth-divider"><span data-lang="en">Other Approaches</span><span data-lang="zh">其他方法</span></div>

<h2 data-lang="en">Beyond Louvain: Other Algorithms</h2>
<h2 data-lang="zh">超越 Louvain：其他算法</h2>

<div class="level-badge intermediate">Intermediate</div>

<div class="concept-row">
  <div class="concept-card">
    <div class="card-icon">S</div>
    <h4 data-lang="en">Spectral Methods</h4>
    <h4 data-lang="zh">谱方法</h4>
    <p data-lang="en">Uses eigenvectors of the modularity matrix. Finds the globally optimal 2-way partition. Good for theoretical understanding.</p>
    <p data-lang="zh">使用模块性矩阵的特征向量。找到全局最优的 2 路分割。有利于理论理解。</p>
  </div>

  <div class="concept-card">
    <div class="card-icon">L</div>
    <h4 data-lang="en">Label Propagation</h4>
    <h4 data-lang="zh">标签传播</h4>
    <p data-lang="en">Nodes adopt the label of their majority neighbors iteratively. Very fast, semi-random, works well on large networks.</p>
    <p data-lang="zh">节点迭代地采用其多数邻居的标签。非常快，半随机，适用于大型网络。</p>
  </div>
</div>

<div class="callout warn">
  <div class="callout-label" data-lang="en">Resolution Limit</div>
  <div class="callout-label" data-lang="zh">分辨率限制</div>
  <p data-lang="en">All modularity-based methods have a fundamental blind spot: they struggle to detect small communities in large networks. Specifically, communities smaller than √(2m) nodes are unreliable, where m is the total edge count.</p>
  <p data-lang="zh">所有基于模块性的方法都有一个根本的盲点：它们很难检测大型网络中的小型社区。具体来说，小于 √(2m) 个节点的社区不可靠，其中 m 是总边数。</p>

  <p data-lang="en"><strong>Example:</strong> A network with 1000 edges cannot reliably detect communities smaller than ~45 nodes.</p>
  <p data-lang="zh"><strong>示例：</strong> 拥有 1000 条边的网络无法可靠地检测到小于 ~45 个节点的社区。</p>
</div>

<div class="depth-divider"><span data-lang="en">Implementation</span><span data-lang="zh">实现</span></div>

<h2 data-lang="en">Using R: igraph Package</h2>
<h2 data-lang="zh">使用 R：igraph 包</h2>

<div class="level-badge advanced">Advanced</div>

<button class="collapsible-toggle" onclick="toggleCollapsible(this)">
  <span class="arrow">→</span>
  <span data-lang="en">Show Code Examples</span>
  <span data-lang="zh">显示代码示例</span>
</button>

<div class="collapsible-content">

<h3 data-lang="en">Basic Louvain Detection</h3>
<h3 data-lang="zh">基础 Louvain 检测</h3>

<pre class="code-block"><span class="comment"># Load igraph and create example network</span>
library(igraph)

g &lt;- graph_from_data_frame(
  data.frame(
    from = c(1,1,1, 2,2,3, 4,4,4, 5,5, 6),
    to   = c(2,3,4, 3,5, 1, 5,6,7, 4,6, 7)
  ),
  directed = FALSE
)

<span class="comment"># Run Louvain algorithm</span>
communities &lt;- cluster_louvain(g)
print(communities)
cat("Modularity Q:", modularity(g, membership(communities)), "\n")</pre>

<h3 data-lang="en">Compare Different Algorithms</h3>
<h3 data-lang="zh">比较不同算法</h3>

<pre class="code-block"><span class="comment"># Run multiple methods</span>
louvain_comm &lt;- cluster_louvain(g)
walktrap_comm &lt;- cluster_walktrap(g, steps = 4)
label_prop &lt;- cluster_label_prop(g)

<span class="comment"># Compare modularity scores</span>
cat("Louvain Q:", modularity(g, membership(louvain_comm)), "\n")
cat("Walktrap Q:", modularity(g, membership(walktrap_comm)), "\n")
cat("Label Prop Q:", modularity(g, membership(label_prop)), "\n")

<span class="comment"># Compare partitions using Adjusted Rand Index</span>
cat("Louvain vs Walktrap ARI:",
    compare(membership(louvain_comm),
            membership(walktrap_comm),
            method = "rand"), "\n")</pre>

<h3 data-lang="en">Visualization</h3>
<h3 data-lang="zh">可视化</h3>

<pre class="code-block"><span class="comment"># Color nodes by community</span>
communities &lt;- cluster_louvain(g)
colors &lt;- rainbow(max(membership(communities)))[membership(communities)]

<span class="comment"># Create force-directed layout</span>
layout &lt;- layout_with_fr(g)

<span class="comment"># Plot with communities highlighted</span>
plot(g,
     layout = layout,
     vertex.color = colors,
     vertex.size = 10,
     edge.color = "gray70",
     main = paste("Communities (Q =",
                  round(modularity(g, membership(communities)), 3), ")"))</pre>

<h3 data-lang="en">Manual Modularity Calculation</h3>
<h3 data-lang="zh">手动模块性计算</h3>

<pre class="code-block"><span class="comment"># Verify Q calculation step-by-step</span>
compute_Q &lt;- function(graph, membership) {
  A &lt;- as_adjacency_matrix(graph, sparse = FALSE)
  n &lt;- length(membership)
  m &lt;- ecount(graph)
  k &lt;- colSums(A)

  Q &lt;- 0
  for (i in 1:n) {
    for (j in 1:n) {
      if (membership[i] == membership[j]) {
        Q &lt;- Q + (A[i,j] - (k[i] * k[j]) / (2 * m))
      }
    }
  }
  return(Q / (2 * m))
}

<span class="comment"># Test: should match igraph::modularity()</span>
mem &lt;- membership(cluster_louvain(g))
cat("Custom Q:", compute_Q(g, mem), "\n")
cat("igraph Q:", modularity(g, mem), "\n")</pre>

</div>

<div class="summary-box">
  <div class="summary-label" data-lang="en">Key Takeaways</div>
  <div class="summary-label" data-lang="zh">关键要点</div>

  <p data-lang="en">
  <strong>Community detection</strong> finds groups of densely-connected nodes in networks without labels. <strong>Modularity Q</strong> is a principled metric comparing actual structure against random expectation—higher is better (typically 0.3+ for significant structure). <strong>Louvain algorithm</strong> is the practical default: fast, scalable, and effective for most networks. <strong>Spectral methods</strong> are theoretically elegant and find global optima for 2-way splits. <strong>All methods struggle with the resolution limit</strong>—they miss small communities in large networks. Always validate your results: compare multiple algorithms, check Q values, and confirm findings against domain knowledge.
  </p>

  <p data-lang="zh">
  <strong>社区检测</strong>在没有标签的网络中找到密集连接的节点组。<strong>模块性 Q</strong> 是一个有原则的指标，将实际结构与随机期望进行比较——越高越好（通常 0.3+ 表示显著结构）。<strong>Louvain 算法</strong>是实用的默认选择：对大多数网络来说速度快、可扩展且有效。<strong>谱方法</strong>在理论上优雅，为 2 路分割找到全局最优值。<strong>所有方法都受到分辨率限制的困扰</strong>——它们在大型网络中错过小型社区。始终验证您的结果：比较多种算法，检查 Q 值，并根据领域知识确认发现。
  </p>
</div>

<script>
function toggleCollapsible(button) {
  button.classList.toggle('open');
  const content = button.nextElementSibling;
  content.classList.toggle('open');
}
</script>
