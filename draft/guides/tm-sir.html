---
layout: methods-guide
title: "SIR Epidemic Model"
title_zh: "SIR 流行病模型"
parent_title: "Theoretical Modeling"
parent_title_zh: "理论建模"
parent_url: "theoretical-modeling.html"
bilingual: true
---

<style>
  .sim-panel{background:var(--paper);border:1px solid var(--parchment);border-radius:4px;padding:24px 28px;margin:16px 0;}
  canvas#sirChart{display:block;border:1px solid var(--parchment);border-radius:3px;width:100%;max-width:680px;}
  .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:18px;}
  .ctrl-group{display:flex;flex-direction:column;gap:6px;}
  .ctrl-label{font-family:var(--sans);font-size:11px;font-weight:500;letter-spacing:.05em;text-transform:uppercase;color:var(--ink-ghost);display:flex;justify-content:space-between;align-items:center;}
  .ctrl-val{font-family:var(--mono);color:var(--red);font-weight:500;}
  input[type=range]{width:100%;accent-color:var(--red);}
  .stat-row{display:flex;gap:12px;margin:16px 0;flex-wrap:wrap;}
  .stat-chip{flex:1;min-width:110px;background:var(--cream);border:1px solid var(--parchment);border-radius:3px;padding:10px 14px;text-align:center;}
  .stat-chip .slabel{font-family:var(--sans);font-size:9px;font-weight:600;letter-spacing:.1em;text-transform:uppercase;color:var(--ink-ghost);display:block;margin-bottom:4px;}
  .stat-chip .sval{font-family:var(--mono);font-size:20px;font-weight:500;}
  .sval.red{color:var(--red);}  .sval.gold{color:var(--gold);}  .sval.green{color:#4A7C59;}
  .legend-row{display:flex;gap:16px;justify-content:center;margin:10px 0;}
  .leg-item{display:flex;align-items:center;gap:6px;font-family:var(--sans);font-size:11px;color:var(--ink-ghost);}
  .leg-line{width:24px;height:3px;border-radius:2px;flex-shrink:0;}
  .math-note{font-family:var(--mono);font-size:12px;background:var(--parchment);padding:12px 16px;border-radius:3px;margin:10px 0;color:var(--ink);line-height:1.8;}
  .insight-box{background:var(--cream);border-left:3px solid var(--gold);padding:14px 18px;margin:14px 0;font-family:var(--serif);font-size:14px;line-height:1.6;color:var(--ink);}
  .sim-btns{display:flex;gap:8px;margin:10px 0;}
  .sim-btn{font-family:var(--sans);font-size:12px;font-weight:600;padding:7px 18px;border:none;border-radius:3px;cursor:pointer;letter-spacing:.03em;transition:background .2s;}
  .sim-btn.run{background:var(--red);color:var(--paper);}
  .sim-btn.run:hover{background:var(--leather);}
  .sim-btn.reset{background:transparent;border:1px solid var(--parchment);color:var(--ink-ghost);}
  .tab-bar{display:flex;gap:0;border-bottom:2px solid var(--parchment);margin-bottom:20px;}
  .tab-btn{font-family:var(--sans);font-size:12px;font-weight:600;letter-spacing:.04em;padding:9px 20px;border:none;background:none;cursor:pointer;color:var(--ink-ghost);border-bottom:2px solid transparent;margin-bottom:-2px;transition:all .2s;}
  .tab-btn.active{color:var(--red);border-bottom-color:var(--red);}
  .tab-pane{display:none;} .tab-pane.active{display:block;}
  #agtCanvas{display:block;border:1px solid var(--parchment);border-radius:3px;}
  .r0-badge{display:inline-block;font-family:var(--mono);font-size:28px;font-weight:700;padding:6px 20px;border-radius:4px;margin:4px 0;}
</style>

<div class="method-header">
  <div class="method-meta">
    <span data-lang="en">INTERACTIVE SIMULATION · MODULE 3</span>
    <span data-lang="zh">互动模拟 · 模块三</span>
  </div>
  <h1>
    <span data-lang="en">SIR Epidemic Model</span>
    <span data-lang="zh">SIR 流行病模型</span>
  </h1>
  <p>
    <span data-lang="en">The workhorse of mathematical epidemiology. Three compartments — Susceptible, Infected, Recovered — governed by two parameters that determine whether an outbreak fades or explodes.</span>
    <span data-lang="zh">数学流行病学的核心模型。三个仓室——易感者（S）、感染者（I）、康复者（R）——由两个参数决定疫情是消退还是爆发。</span>
  </p>
</div>

<hr class="section-divider">

<section>
  <h2><span data-lang="en">The Model, Piece by Piece</span><span data-lang="zh">模型逐步拆解</span></h2>
  <p>
    <span data-lang="en"><strong>Three compartments.</strong> At any moment, every person in the population belongs to one of three groups: <strong>Susceptible (S)</strong> — healthy but can catch the disease; <strong>Infectious (I)</strong> — currently infected and able to spread it; <strong>Recovered (R)</strong> — no longer infectious and now immune. S + I + R = N (the total population) at all times.</span>
    <span data-lang="zh"><strong>三个仓室。</strong>在任何时刻，种群中的每个人都属于以下三组之一：<strong>易感者（S）</strong>——健康但可能被感染；<strong>感染者（I）</strong>——当前感染并能传播疾病；<strong>康复者（R）</strong>——不再具有传染性且已获免疫。S + I + R = N（总人口）始终成立。</span>
  </p>
  <p>
    <span data-lang="en"><strong>Why does S decrease at rate β·S·I/N?</strong> This is the key term and it comes from a simple probability argument. Each infected person makes β random contacts per day. The probability that any given contact is with a susceptible person is S/N (the current fraction of the population that is susceptible). So each infected person infects β · S/N people per day. With I infected people, the total new infections per day is β · S/N · I = β·S·I/N. That S×I product is crucial: transmission slows as either susceptibles run out (S falls) or infected people recover (I falls).</span>
    <span data-lang="zh"><strong>为什么 S 以 β·S·I/N 的速率减少？</strong>这是关键项，来自简单的概率推导。每名感染者每天随机接触 β 次。任意一次接触对象是易感者的概率为 S/N（当前易感者占总人口的比例）。因此每名感染者每天感染 β · S/N 人。I 名感染者共产生 β · S/N · I = β·S·I/N 的新增感染。S×I 乘积至关重要：随着易感者减少（S 下降）或感染者康复（I 下降），传播自然减速。</span>
  </p>
  <p>
    <span data-lang="en"><strong>The two parameters.</strong> <strong>β</strong> (beta) is the transmission rate — how many people an infected person contacts and infects per unit time if everyone were susceptible. Higher β means more contagious. <strong>γ</strong> (gamma) is the recovery rate — the fraction of infecteds who recover per day. If you're infectious for an average of 5 days, then γ = 1/5 = 0.2 (you have a 20% chance of recovering on any given day).</span>
    <span data-lang="zh"><strong>两个参数。</strong><strong>β</strong>（beta）是传播率——如果所有人都是易感者，每名感染者每单位时间接触并感染的人数。β 越高越有传染性。<strong>γ</strong>（gamma）是康复率——每天康复的感染者比例。如果平均感染期为 5 天，则 γ = 1/5 = 0.2（每天有 20% 的概率康复）。</span>
  </p>
  <div class="math-note">
    dS/dt = −β · S · I / N<br>
    dI/dt =  β · S · I / N  − γ · I<br>
    dR/dt =  γ · I<br><br>
    R₀ = β / γ
  </div>
  <h3><span data-lang="en">Understanding R₀ and Herd Immunity</span><span data-lang="zh">理解 R₀ 与群体免疫</span></h3>
  <p>
    <span data-lang="en"><strong>R₀ (R-nought)</strong> is the basic reproduction number: the expected number of new infections caused by a single infectious person, assuming <em>everyone</em> in the population is susceptible. It is simply β/γ because each infected person infects β·1 people per day (when S/N = 1) and stays infectious for an average of 1/γ days, giving β × 1/γ = β/γ total infections.</span>
    <span data-lang="zh"><strong>R₀</strong>（R 零）是基本传染数：假设种群中<em>所有人</em>均为易感者，单个感染者预计引发的新感染数。它等于 β/γ，因为每名感染者每天感染 β·1 人（当 S/N = 1 时），平均感染期为 1/γ 天，共产生 β × 1/γ = β/γ 次感染。</span>
  </p>
  <p>
    <span data-lang="en"><strong>Epidemic threshold.</strong> The epidemic grows when each case produces more than one new case, i.e., R₀ × S/N > 1. As susceptibles are depleted (S decreases), the effective reproduction number Re = R₀ × S/N falls below 1, and the epidemic peaks and then declines. The epidemic peak happens exactly when S/N = 1/R₀, i.e., when S = N/R₀.</span>
    <span data-lang="zh"><strong>流行病阈值。</strong>当每个病例产生超过一个新病例时，即 R₀ × S/N > 1 时，疫情增长。随着易感者耗尽（S 减少），有效传染数 Re = R₀ × S/N 降至 1 以下，疫情达到峰值后下降。流行病峰值恰好在 S/N = 1/R₀，即 S = N/R₀ 时出现。</span>
  </p>
  <p>
    <span data-lang="en"><strong>Herd immunity threshold.</strong> If a fraction h of the population is already immune (recovered or vaccinated), then only (1−h) of the population is susceptible. The effective R is then R₀ × (1−h). The epidemic can only grow if R₀ × (1−h) > 1, i.e., when h < 1 − 1/R₀. So the herd immunity threshold is h* = 1 − 1/R₀: if this fraction is immune, the remaining susceptibles are too sparse for the epidemic to grow. For COVID-19 (original, R₀ ≈ 2.5), that's h* = 1 − 1/2.5 = 60%.</span>
    <span data-lang="zh"><strong>群体免疫阈值。</strong>若种群中已有比例 h 获得免疫（康复或接种疫苗），则只有 (1−h) 的人口是易感者。有效传染数变为 R₀ × (1−h)。疫情仅在 R₀ × (1−h) > 1，即 h < 1 − 1/R₀ 时增长。因此群体免疫阈值为 h* = 1 − 1/R₀：若该比例的人口获得免疫，剩余易感者过于分散，疫情无法增长。对于 COVID-19（原始毒株，R₀ ≈ 2.5），h* = 1 − 1/2.5 = 60%。</span>
  </p>
  <p>
    <span data-lang="en"><strong>Important caveat: the overshoot.</strong> When immunity is acquired during an epidemic (rather than through pre-existing vaccination), the system doesn't stop exactly at h*. By the time enough people recover to bring Re below 1, the epidemic has "momentum" — there are still many infected people who will go on to infect more. The epidemic always overshoots the threshold. The ODE simulation makes this visible: the final R value is always higher than h*, and the epidemic ends not because everyone got infected, but because susceptibles became too sparse to sustain transmission.</span>
    <span data-lang="zh"><strong>重要注意：过冲现象。</strong>当免疫力通过流行过程中的感染获得（而非通过预先接种疫苗）时，系统不会精确停在 h* 处。当足够多的人康复使 Re 降至 1 以下时，疫情已有"惯性"——仍有许多感染者会继续传播。疫情总是超过阈值。ODE 模拟使这一点清晰可见：最终 R 值总是高于 h*，疫情的结束不是因为所有人都被感染，而是因为易感者变得太稀少，无法维持传播。</span>
  </p>
</section>

<hr class="section-divider">

<section>
  <div class="tab-bar">
    <button class="tab-btn active" data-tab="ode">
      <span data-lang="en">ODE Solution</span><span data-lang="zh">常微分方程解</span>
    </button>
    <button class="tab-btn" data-tab="agt">
      <span data-lang="en">Agent-Based Simulation</span><span data-lang="zh">基于主体模拟</span>
    </button>
  </div>

  <!-- ODE tab -->
  <div class="tab-pane active" id="tab-ode">
    <p>
      <span data-lang="en">Numerical integration (Euler method, dt = 0.1) of the SIR ODEs. Adjust β and γ to see how the epidemic curve changes. Watch R₀ and the final epidemic size respond in real time.</span>
      <span data-lang="zh">SIR 常微分方程的数值积分（欧拉方法，dt = 0.1）。调整 β 和 γ，观察流行病曲线的变化。实时观察 R₀ 和最终疫情规模的响应。</span>
    </p>

    <div class="sim-panel">
      <div class="stat-row">
        <div class="stat-chip">
          <span class="slabel">R₀ = β/γ</span>
          <span class="sval" id="r0Val" style="color:var(--red);">2.50</span>
        </div>
        <div class="stat-chip">
          <span class="slabel" data-lang="en">Herd Immunity Threshold</span><span class="slabel" data-lang="zh">群体免疫阈值</span>
          <span class="sval" id="hitVal" style="color:var(--gold);">60%</span>
        </div>
        <div class="stat-chip">
          <span class="slabel" data-lang="en">Final Epidemic Size</span><span class="slabel" data-lang="zh">最终疫情规模</span>
          <span class="sval" id="fesVal" style="color:#4A7C59;">—%</span>
        </div>
        <div class="stat-chip">
          <span class="slabel" data-lang="en">Peak Infected</span><span class="slabel" data-lang="zh">感染峰值</span>
          <span class="sval" id="peakVal" style="color:var(--red);">—%</span>
        </div>
      </div>

      <div style="display:flex;justify-content:center;margin:12px 0;">
        <canvas id="sirChart" width="680" height="300"></canvas>
      </div>

      <div class="legend-row">
        <div class="leg-item"><div class="leg-line" style="background:#4A7C59;"></div><span data-lang="en">Susceptible (S)</span><span data-lang="zh">易感者 (S)</span></div>
        <div class="leg-item"><div class="leg-line" style="background:#B5372A;"></div><span data-lang="en">Infected (I)</span><span data-lang="zh">感染者 (I)</span></div>
        <div class="leg-item"><div class="leg-line" style="background:#C2993D;"></div><span data-lang="en">Recovered (R)</span><span data-lang="zh">康复者 (R)</span></div>
      </div>

      <div class="controls-grid">
        <div class="ctrl-group">
          <div class="ctrl-label">
            <span data-lang="en">β — Transmission rate</span><span data-lang="zh">β — 传播率</span>
            <span class="ctrl-val" id="betaVal">0.50</span>
          </div>
          <input type="range" id="sBeta" min="0.05" max="2.0" value="0.5" step="0.05">
        </div>
        <div class="ctrl-group">
          <div class="ctrl-label">
            <span data-lang="en">γ — Recovery rate</span><span data-lang="zh">γ — 康复率</span>
            <span class="ctrl-val" id="gammaVal">0.20</span>
          </div>
          <input type="range" id="sGamma" min="0.05" max="1.0" value="0.2" step="0.05">
        </div>
        <div class="ctrl-group">
          <div class="ctrl-label">
            <span data-lang="en">Initial infected (%)</span><span data-lang="zh">初始感染比例</span>
            <span class="ctrl-val" id="i0Val">1%</span>
          </div>
          <input type="range" id="sI0" min="0.1" max="10" value="1" step="0.1">
        </div>
        <div class="ctrl-group">
          <div class="ctrl-label">
            <span data-lang="en">Time horizon (days)</span><span data-lang="zh">时间跨度（天）</span>
            <span class="ctrl-val" id="tMaxVal">200</span>
          </div>
          <input type="range" id="sTMax" min="50" max="500" value="200" step="10">
        </div>
      </div>
    </div>

    <div class="insight-box">
      <strong data-lang="en">Herd immunity threshold: </strong><strong data-lang="zh">群体免疫阈值：</strong>
      <span data-lang="en">1 − 1/R₀. If this fraction of the population is immune, each case produces &lt;1 new case on average and the epidemic fades. Notice that even if the threshold is reached during the epidemic, inertia carries infections past it — the overshoot is determined by the shape of the epidemic curve, not just R₀.</span>
      <span data-lang="zh">1 − 1/R₀。若该比例的人口已获免疫，每个病例平均产生不足一个新病例，疫情将消退。注意，即使疫情期间达到群体免疫阈值，由于惯性，感染仍会超过此阈值——超调量由疫情曲线形状决定，而不仅仅由 R₀ 决定。</span>
    </div>
  </div>

  <!-- Agent-Based tab -->
  <div class="tab-pane" id="tab-agt">
    <p>
      <span data-lang="en">A stochastic agent-based version with 400 agents on a 2D space. Agents move randomly; susceptibles become infected by proximity to infecteds. Observe how stochasticity and spatial clustering change the epidemic shape compared to the ODE model.</span>
      <span data-lang="zh">400 个主体在二维空间中随机移动的随机主体模型。易感者通过与感染者的接近而感染。观察随机性和空间聚集如何改变疫情形状（相对于 ODE 模型）。</span>
    </p>

    <div class="sim-panel">
      <div style="display:flex;gap:16px;flex-wrap:wrap;align-items:flex-start;">
        <canvas id="agtCanvas" width="320" height="320"></canvas>
        <div style="flex:1;min-width:200px;">
          <canvas id="agtChart" width="280" height="200" style="border:1px solid var(--parchment);border-radius:3px;display:block;width:100%;"></canvas>
          <div class="stat-row" style="margin-top:10px;">
            <div class="stat-chip"><span class="slabel">S</span><span class="sval" id="aS" style="color:#4A7C59;">—</span></div>
            <div class="stat-chip"><span class="slabel">I</span><span class="sval" id="aI" style="color:var(--red);">—</span></div>
            <div class="stat-chip"><span class="slabel">R</span><span class="sval" id="aR" style="color:var(--gold);">—</span></div>
          </div>
        </div>
      </div>
      <div class="sim-btns" style="margin-top:12px;">
        <button class="sim-btn run" id="agtRun"><span data-lang="en">▶ Run</span><span data-lang="zh">▶ 运行</span></button>
        <button class="sim-btn pause" style="background:var(--gold);color:var(--paper);" id="agtPause" disabled><span data-lang="en">⏸ Pause</span><span data-lang="zh">⏸ 暂停</span></button>
        <button class="sim-btn reset" id="agtReset"><span data-lang="en">↺ Reset</span><span data-lang="zh">↺ 重置</span></button>
      </div>
      <div class="controls-grid" style="margin-top:12px;">
        <div class="ctrl-group">
          <div class="ctrl-label"><span data-lang="en">Infection radius</span><span data-lang="zh">感染半径</span><span class="ctrl-val" id="aRadVal">20</span></div>
          <input type="range" id="aRad" min="5" max="50" value="20" step="1">
        </div>
        <div class="ctrl-group">
          <div class="ctrl-label"><span data-lang="en">Infection prob / step</span><span data-lang="zh">每步感染概率</span><span class="ctrl-val" id="aProbVal">0.05</span></div>
          <input type="range" id="aProb" min="0.01" max="0.3" value="0.05" step="0.01">
        </div>
      </div>
    </div>
  </div>
</section>

<hr class="section-divider">

<div class="page-nav">
  <a class="pn-link pn-prev" href="/methods/guides/tm-ca.html">
    <span class="pn-arrow">←</span>
    <span>
      <span class="pn-dir" data-lang="en">Previous</span><span class="pn-dir" data-lang="zh">上一篇</span>
      <span class="pn-title" data-lang="en">Cellular Automata</span><span class="pn-title" data-lang="zh">元胞自动机</span>
    </span>
  </a>
  <a class="pn-link pn-next" href="/methods/guides/tm-opinions.html">
    <span>
      <span class="pn-dir" data-lang="en">Next</span><span class="pn-dir" data-lang="zh">下一篇</span>
      <span class="pn-title" data-lang="en">Opinion Dynamics</span><span class="pn-title" data-lang="zh">观点动态</span>
    </span>
    <span class="pn-arrow">→</span>
  </a>
</div>

<script>
// ── Tab switching ────────────────────────────────────────────────
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('.tab-pane').forEach(p=>p.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-'+btn.dataset.tab).classList.add('active');
  });
});

// ── ODE SIR ─────────────────────────────────────────────────────
const chart = document.getElementById('sirChart');
const cctx = chart.getContext('2d');
const CW=chart.width, CH=chart.height;
const PAD={top:20,right:20,bottom:40,left:50};

function solveSIR(beta, gamma, i0frac, tMax, dt=0.1) {
  let S=1-i0frac, I=i0frac, R=0;
  const ts=[],Ss=[],Is=[],Rs=[];
  for (let t=0; t<=tMax; t+=dt) {
    ts.push(t); Ss.push(S); Is.push(I); Rs.push(R);
    const dS=-beta*S*I, dI=beta*S*I-gamma*I, dR=gamma*I;
    S=Math.max(0,S+dS*dt); I=Math.max(0,I+dI*dt); R=Math.min(1,R+dR*dt);
    if (I<1e-8 && t>10) break;
  }
  return {ts,Ss,Is,Rs};
}

function drawODE() {
  const beta=+document.getElementById('sBeta').value;
  const gamma=+document.getElementById('sGamma').value;
  const i0=+document.getElementById('sI0').value/100;
  const tMax=+document.getElementById('sTMax').value;
  const {ts,Ss,Is,Rs}=solveSIR(beta,gamma,i0,tMax);

  // stats
  const r0=(beta/gamma).toFixed(2);
  const hit=Math.max(0,1-1/(beta/gamma));
  const fes=(Rs[Rs.length-1]*100).toFixed(1);
  const peak=(Math.max(...Is)*100).toFixed(1);
  document.getElementById('r0Val').textContent=r0;
  document.getElementById('r0Val').style.color=beta/gamma>1?'var(--red)':'#4A7C59';
  document.getElementById('hitVal').textContent=(hit*100).toFixed(1)+'%';
  document.getElementById('fesVal').textContent=fes+'%';
  document.getElementById('peakVal').textContent=peak+'%';

  // draw
  cctx.clearRect(0,0,CW,CH);
  cctx.fillStyle='#F9F7F3'; cctx.fillRect(0,0,CW,CH);
  const PW=CW-PAD.left-PAD.right, PH=CH-PAD.top-PAD.bottom;
  const T=ts[ts.length-1];

  function px(t){return PAD.left+t/T*PW;}
  function py(v){return PAD.top+(1-v)*PH;}

  // axes
  cctx.strokeStyle='#D4CCC4'; cctx.lineWidth=1;
  cctx.beginPath(); cctx.moveTo(PAD.left,PAD.top); cctx.lineTo(PAD.left,PAD.top+PH); cctx.lineTo(PAD.left+PW,PAD.top+PH); cctx.stroke();

  // gridlines + y labels
  cctx.fillStyle='#999'; cctx.font='10px IBM Plex Mono,monospace'; cctx.textAlign='right';
  [0,0.25,0.5,0.75,1.0].forEach(v => {
    const y=py(v);
    cctx.fillStyle='rgba(212,204,196,0.5)';
    cctx.fillRect(PAD.left,y,PW,0.5);
    cctx.fillStyle='#999';
    cctx.fillText((v*100)+'%', PAD.left-6, y+3.5);
  });

  // x labels
  cctx.textAlign='center';
  const step=Math.ceil(T/5/10)*10;
  for(let t=0;t<=T;t+=step){
    cctx.fillText(t, px(t), PAD.top+PH+14);
  }
  cctx.fillStyle='#888'; cctx.font='10px IBM Plex Sans,sans-serif';
  cctx.fillText('Days', PAD.left+PW/2, CH-4);

  function drawLine(data,color,lw=2) {
    cctx.beginPath(); cctx.strokeStyle=color; cctx.lineWidth=lw;
    data.forEach((v,i)=>i===0?cctx.moveTo(px(ts[i]),py(v)):cctx.lineTo(px(ts[i]),py(v)));
    cctx.stroke();
  }
  drawLine(Ss,'#4A7C59');
  drawLine(Is,'#B5372A',2.5);
  drawLine(Rs,'#C2993D');
}

['sBeta','sGamma','sI0','sTMax'].forEach(id => {
  const el=document.getElementById(id);
  el.addEventListener('input', () => {
    const map={sBeta:'betaVal',sGamma:'gammaVal',sI0:'i0Val',sTMax:'tMaxVal'};
    const suffix={sI0:'%',sTMax:''};
    let val=+el.value;
    let txt = id==='sI0' ? val.toFixed(1)+'%' : id==='sTMax' ? val : val.toFixed(2);
    document.getElementById(map[id]).textContent=txt;
    drawODE();
  });
});

drawODE();

// ── Agent-Based SIR ──────────────────────────────────────────────
const AC=document.getElementById('agtCanvas');
const actx=AC.getContext('2d');
const AW=AC.width, AH=AC.height;
const ACh=document.getElementById('agtChart');
const acctx=ACh.getContext('2d');
const ACW=ACh.width, ACH=ACh.height;

const N=400;
let agents=[], aRunning=false, aRaf=null, aStep=0, aHistory=[];

function aInit() {
  aRunning=false; aStep=0; aHistory=[];
  document.getElementById('agtRun').disabled=false;
  document.getElementById('agtPause').disabled=true;
  agents=Array.from({length:N},(_,i)=>({
    x:Math.random()*AW, y:Math.random()*AH,
    vx:(Math.random()-.5)*2, vy:(Math.random()-.5)*2,
    state: i<3?'I':'S',
    timer: i<3 ? 50+Math.random()*100 : 0
  }));
  aDrawAll();
}

function aDoStep() {
  const rad=+document.getElementById('aRad').value;
  const prob=+document.getElementById('aProb').value;
  // move
  agents.forEach(a=>{
    a.x+=a.vx; a.y+=a.vy;
    if(a.x<0||a.x>AW) a.vx*=-1;
    if(a.y<0||a.y>AH) a.vy*=-1;
    a.x=Math.max(0,Math.min(AW,a.x));
    a.y=Math.max(0,Math.min(AH,a.y));
  });
  // infect
  const infected=agents.filter(a=>a.state==='I');
  agents.forEach(a=>{
    if(a.state!=='S') return;
    for(const inf of infected) {
      const dx=a.x-inf.x, dy=a.y-inf.y;
      if(dx*dx+dy*dy<rad*rad && Math.random()<prob) { a.state='I'; a.timer=80+Math.random()*80; break; }
    }
  });
  // recover
  agents.forEach(a=>{ if(a.state==='I'){ a.timer--; if(a.timer<=0) a.state='R'; }});
  aStep++;
  aDrawAll();
}

function aDrawAll() {
  actx.fillStyle='#F9F7F3'; actx.fillRect(0,0,AW,AH);
  const colors={S:'#4A7C59',I:'#B5372A',R:'#C2993D'};
  agents.forEach(a=>{
    actx.beginPath(); actx.arc(a.x,a.y,4,0,Math.PI*2);
    actx.fillStyle=colors[a.state]; actx.fill();
  });
  const S=agents.filter(a=>a.state==='S').length;
  const I=agents.filter(a=>a.state==='I').length;
  const R=agents.filter(a=>a.state==='R').length;
  document.getElementById('aS').textContent=S;
  document.getElementById('aI').textContent=I;
  document.getElementById('aR').textContent=R;
  aHistory.push({S,I,R});
  if(aHistory.length>200) aHistory.shift();
  aDrawChart();
}

function aDrawChart() {
  acctx.fillStyle='#F9F7F3'; acctx.fillRect(0,0,ACW,ACH);
  if(aHistory.length<2) return;
  const total=N;
  function draw(key,color) {
    acctx.beginPath(); acctx.strokeStyle=color; acctx.lineWidth=1.5;
    aHistory.forEach((d,i)=>{
      const x=i/aHistory.length*ACW, y=(1-d[key]/total)*ACH;
      i===0?acctx.moveTo(x,y):acctx.lineTo(x,y);
    });
    acctx.stroke();
  }
  draw('S','#4A7C59'); draw('I','#B5372A'); draw('R','#C2993D');
}

let aLast=0;
function aLoop(t) {
  aRaf=requestAnimationFrame(aLoop);
  if(!aRunning) return;
  if(t-aLast>50) { aDoStep(); aLast=t; }
}

document.getElementById('agtRun').addEventListener('click',()=>{
  aRunning=true;
  document.getElementById('agtRun').disabled=true;
  document.getElementById('agtPause').disabled=false;
});
document.getElementById('agtPause').addEventListener('click',()=>{
  aRunning=false;
  document.getElementById('agtRun').disabled=false;
  document.getElementById('agtPause').disabled=true;
});
document.getElementById('agtReset').addEventListener('click', aInit);
document.getElementById('aRad').addEventListener('input',e=>document.getElementById('aRadVal').textContent=e.target.value);
document.getElementById('aProb').addEventListener('input',e=>document.getElementById('aProbVal').textContent=e.target.value);

aInit();
requestAnimationFrame(aLoop);
</script>
